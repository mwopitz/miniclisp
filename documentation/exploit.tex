\section{Exploit}
In dem Interpreter befindet sich ein sogennanter Off-By-One Fehler. Fehler dieser Art können sich sehr schnell in ein Programm einschleichen. Ein typisches Beispiel wäre dass der Programmierer die Länge eines Array und den Index des letzten Elements gleichsetzt obwohl die Nummerierung bei C mit 0 beginnt. Off-By-One Fehler sind nur unter sehr bestimmten Vorraussetzungen exploit-bar und sind dadurch von Programm zu Programm sehr unterschiedlich. Deshalb können kleine Änderungen an dem Programm schnell dazu führen, dass es nicht mehr exploitbar oder der Exploit komplett anders zu gestalten ist.
\subsection{Aktivierte Sicherheitsmechanismen}
Das Exploit kann mit einigen üblichen Sicherheitsmechanismen ausgeführt werden. Zur Entwicklung wurde ein Ubuntu 10.10 und ein Arch Linux\footnote{Neuste Version vom 1.6.2014 z.B. kernel: 3.15.2, gcc-Version 4.9.0, glibc 2.19} benutzt. Dabei war ASLR standardmäßig aktiviert und der Stack nicht ausführbar (ebenso Standard im gcc). Zusätzlich ist der GCC StackGuard aktiviert was jedoch keine Rolle spielt für das Exploit. Nicht aktiviert sind Sicherheitsmechanismen wie "position independent executable"(-fPIE).
\\
Diese Sicherheitskonfiguration spiegelt auch aktuelle Systeme sehr gut wieder und ist auch häufig anzutreffen. Um die Gefahr solcher Lücken zu demonstrieren wurde die binary mit einem speziellen Benutzer und mit dem Setuid-Flag platziert. Das Setuid-Flag wäre in der aktuellen Konfiguration nicht unbedingt notwendig aber ein Szenario in dem ein Benutzer eine Scheme Datei aus unsicherer Quelle mit eigenem Bneutzer interpretiert wäre vergleichbar. Die Datei wurde auf dem hacky2 Rechner des Binary Exploitation Praktikums der TU-München installiert und als Eigentümer wurde der Benutzer "r00t" verwendet.

\subsection{Der Off-By-One Fehler}
\label{luecke}
Der Off-By-One Fehler geschieht in der der read Funktion.\\
 Jedes Token das eingelesen wird hat eine maximale Länge (\texttt{MAXTOKENLEN}). Das bedeutet eine neu angelegte Variable z.B. mit define darf nur begrentzt lang sein.
Das String-Array das ein Symbol speichern soll hat genau diese Länge: \texttt{char symvalue[MAXTOKENLEN]}. Direkt in der read Funktion wird bei zu großen Tokens ein Fehler ausgegeben, falls der Check if \texttt{tokenlen > MAXTOKENLEN} fehlschlägt. 
Hier ist bereits der Fehler zu erkennen da dass Array einen C-String der Länge \texttt{tokenlen} nicht speichern kann, da von den restlichen Programmteilen ein normaler C-String mit Null Terminierung erwartet wird. 
Die neue Expression wird dann schließlich in der Funktion \texttt{create\_exprsym(const char *s)} erstellt. Hier wird zuerst eine leere Expression erzeugt und dann mit Hilfe von 
\begin{lstlisting} 
strncat(new->symvalue, s, MAXTOKENLEN);
\end{lstlisting} mit dem String gefüllt. Ist nun der String s genau \texttt{MAXTOKENLEN} lang fügt \texttt{strncat} nach dieser Länge ein 0 Byte an, dass sich dann nicht mehr innerhalb des Arrays befindet. \\
Wie bereits in \ref{datenstrukturen} beschrieben befindet sich nach der symvalue direkt der Typ der Expression: \texttt{enum exprtype type}. Dieser wird jetzt mit dem 0 Byte von strncat überschrieben und so wird aus einer Expression des Types: \texttt{EXPRSYM} eine Expression mit dem Typen: \texttt{EXPRPROC}.\\
Wird diese Expression nun interpretiert liefert sie anstatt dem Variablenwert des Symbols eine Prozedur die anschließend ausgeführt wird. Da unions verwendet wurden werden nun die ersten 4 bytes des strings als Adresse zu einer Prozedur interpretiert.
Beispielsweise liefert folgende Eingabe
\begin{lstlisting}
> (define test abcdeeeeeeffffffffff
		gggggggggghh)
> test
 PROC: 0x64636261 
\end{lstlisting}
Dies bedeutet, dass unter dem Symbol test ab jetzt eine Prozedur vergleichbar mit '+' gespeichert ist. 
Genau wie anderen Prozeduren können der Prozedur Parameter übergeben werden. 
Dies sind mehrere Expressions die mit Hilfe eines next Pointers verbunden sind. Der Prozedur werden nur aufgelöste Werte übergeben. In unserem Fall ist der einzige Basis Typ ein 64 bit langer \texttt{long long int}. \\
Dies bedeutet dass wir der Prozedur nur \texttt{long long int} übergeben können. 
Ein Zeiger auf den ersten Wert wird direkt der Prozedur übergeben und kann somit auch für C Funktionen genutzt werden die nicht  wissen was eine Expression ist. 
Nehmen wir an dass wir eine Prozedur mit der Adresse der Linux system libc Funktion definiert haben, dann könnte man mit 
\begin{lstlisting}
(define systemproc 0x68732f6e69622f)
\end{lstlisting}
die Funktion \texttt{system} aufrufen mit einem Zeiger auf den \texttt{long long int} der als \texttt{char *} interpretiert \texttt{'/bin/sh'} wird. Dadurch würde sich eine interaktive Shell öffnen.
\subsection{Bestandteile des Exploits}
Das Exploit besteht im Grunde aus 3 Teilen die gegenseitig von einander benutzt werden.
\begin{enumerate}
\item Die Bash Datei exploit.sh beinhaltet den Hauptteil des Exploits. Da es für das Exploit notwendig ist mit dem Interpreter dynamisch zu interagieren werden temporär noch einige Dateien durch dieses Bash-Skript erzeugt. 
Alternativ wäre das Paket \texttt{expect}\footnote{\url{http://expect.sourceforge.net/}} zu verwendet, was die Interaktion erleichtert jedoch auf dem Zielsystem nicht verfügbar war. 
Um die Ausgabe in die Eingabe mit einzubeziehen wird mit Hilfe einer Redirection die Ausgabe in eine Datei umgeleitet. Diese Datei wird dann während der Eingabe mit einbezogen werden. 
In Bash kann dies z.B. so realisiert werden 
\begin{lstlisting}
(	echo "a"; 
	sleep 1; 
	verarbeiteAusgabe; 
	echo verarbeiteteAusgabe
	) | ./interpreter > output.txt
\end{lstlisting}
\item Das kleine C-Programm hexto32binary nimmt 4 Parameter. Der erste Eingabe Parameter ist eine Adresse, danach das Offset was von der Adresse abgezogen werden soll. Als drittes wird wieder eine Adresse übergeben und anschließend wieder ein Offset.
Die Übergabe passiert einfach anhand eines Strings der als hex oder int eine Zahl repräsentiert. Das C-Programm berechnet die neuen Adressen mithilfe der Offsets und gibt anschließend einen genau 32 byte langen String aus.
 Die ersten 4 byte des Strings sind die ASCII Zeichen die die erste Adresse im little Endian format repräsentiert. 
Die Bytes 10-14 sind wiederum die neu berechnete 2 Adresse. Die chars 0x0, '(', ')', ' ' werden durch Fülbuchstaben ersetzt. Die restlichen Bytes werden aufgefüllt mit 'a's.
\item Das Bash-Skript s.sh beinhaltet die Shell commands die die erreichte Shell ausführen soll. Dort werden die Streams angepasst und dann eine interaktive Shell mit \texttt{'/bin/sh'} gestartet.
\end{enumerate}
\subsection{Vorgehen}
Das Exploit lässt sich in mehrer Schritte unterteilen, die im Folgenden näher beleuchtet werden sollen. Anfangs wird durch aussnutzen der Lücke beschriben in \ref{luecke} eine Prozedur \texttt{printfproc} definierti, die über die GOT die libc printf Funktion aufruft. Nun können wir printf direkt aus lisp heraus aufrufen und einen maximal 8 byte (\texttt{sizeof(long long int}) langen String übergeben.
 Zuerst rufen wir printf mit \texttt{"\%2\$p\textbackslash n"} und \texttt{"\%9\$p\textbackslash n"} auf, dies liefert eine Adresse aus der libc und eine Adresse aus dem heap, die beide randomisiert sind. 
Da die Offsets innerhalb der libc konstant sind kann durch den ersten Wert die Adresse von system berechnet werden. Da auch malloc deterministisch arbeitet kann aus der zweiten Adresse die Adresse einer bestimmten Expression im Heap berechnet werden.
\begin{lstlisting}
> (define printfproc \x60\x86\x04\x08aaa
	aaabbbbbbbbbbccccccccccdd)
> (printfproc 0xa70243225)
> 0x667440
> (printfproc 0xa70243925)
> 0x8417838
\end{lstlisting}
Wie hier auffält ist die libc Library in einen sehr niedrigen Speicherbereich gemapped wodurch die Adresse von system auch mit  \texttt{0x00} beginnt. Dadurch wird es notwendig das 0 Byte nachträglich noch in der Adresse zu setzen da innerhalb keines Symbols EOF vorkommen darf, was die Verabreitung beenden würde.
Mit Hilfe dieser Adressen werden nun die Adressen von system (hier: 0x168680) und der systemproc Expression (hier: 0x0804e9fb) die erst noch angelegt wird ermittlet.
\begin{lstlisting}
> (define systemproc \x80\x86\x16raaaaaa
	\xfb\xe9\x04\x08aaaaaaaaaaaaaaaa)
\end{lstlisting}
Das "r" muss nun noch durch eine 0 ersetzt werden. 
Dazu benutzen wir die Adresse die an Position 10 des Strings steht. 
Diese Adresse zeigt genau auf das "r" weiter vorne. 
Nun rufen wir noch einmal \texttt{printfproc} auf mit dem Format-String "\texttt{\%103\$n\textbackslash n}". Mit dem Offset von 103 wir genau die Adresse 0x0804e9fb von getroffen. Da noch keine Zeichen innerhalb des Format-Strings ausgegeben wurden wird 0 an die Stelle geschriebeni (32 bit also werden auch die drei auf das 'r' flogenden 'a's mit Nullen überschrieben.
\\
Nun rufen wir \texttt{systemproc} mit './s.sh' auf um den Inhalt der './s.sh' Datei auszuführen.
\begin{lstlisting}
> (systemproc 0x68732e732f2e)
\end{lstlisting}
In der s.sh Datei werden einige Dateiströme wieder auf stdin und stdout gesetzt und dann eine interaktive Shell geöffnet.
\subsection{Ergebnis}
Auch ein einfacher Off-By-One Fehler kann zu schwerwiegenden Folgen führen und der Compiler kann wenig dagegen unternehmen. 
Einzige Vorraussetzung war, dass die printf funktion in der plt verfügbar ist und keine Zeichen wie 0x00,'(',')',' ' enthält. Andere Konflikte wie z.B. 0x00 in der system Adresse können umgangen werden. \\
Generell ist bei Funktions-Pointern immer ein gewisses Maß an Vorsicht zu benutzen.



