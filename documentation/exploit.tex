\section{Exploit}
In dem Interpreter befindet sich ein sogennanter Off-By-One Fehler. Fehler dieser Art können sich sehr schnell in ein Programm einschleichen. Ein typisches Beispiel wäre dass der Programmierer die Länge eines Array und den Index des letzten Elements gleichsetzt obwohl die Nummerierung bei C mit 0 beginnt. Off-By-One Fehler sind nur unter sehr bestimmten Vorraussetzungen exploit-bar und sind dadurch von Programm zu Programm sehr unterschiedlich. Deshalb können kleine Änderungen an dem Programm schnell dazu führen, dass es nicht mehr exploitbar oder der Exploit komplett anders zu gestalten ist.
\subsection{Aktivierte Sicherheitsmechanismen}
Das Exploit kann mit einigen üblichen Sicherheitsmechanismen ausgeführt werden. Zur Entwicklung wurde ein Ubuntu 10.10 und ein ArchLinux\footnote{Neuste Version vom 1.6.2014 z.B. kernel: 3.15.2, gcc-Version 4.9.0, glibc 2.19} benutzt. Dabei war ASLR standardmäßig aktiviert und der Stack nicht außführbar (ebenso standard im gcc). Zusätzlich war ist der GCC StackGuard aktiviert was jedoch keine Rolle spielt für das Exploit. Nicht aktiviert Sicherheitsmechanismen wie "position independent code"(-fPIC).
\\
Diese Sicherheitskonfiguration spiegelt auch aktuelle Systeme sehr gut wieder und ist auch häufig anzutreffen. Um die Gefahr solcher Lücken zu demonstrieren wurde die binary mit einem speziellen Benutzer und mit dem Setuid-Flag platziert. Das Setuid-Flag wäre in der aktuellen Konfiguration nicht unbedingt notwendig aber ein Szenario in dem ein Benutzer eine Scheme Datei aus unsicherer Quelle mit eigenem Bneutzer interpretiert wäre vergleichbar. Die Datei wurde auf dem hacky2 Rechner des Binary Exploitation Praktikums der TU-München installiert und als Eigentümer wurde der Benutzer "r00t" verwendet.

\subsection{Der Off-By-One Fehler}
\label{luecke}
Der Off-By-One Fehler geschieht in der während der read Funktion.\\
 Jedes Token das eingelesen wird hat eine maximale Länge(\texttt{MAXTOKENLEN}). Das bedeutet eine neu angelegte Variable z.B. mit define darf nur begrentzt lang sein.
Das String-Array das ein Symbol speichern soll hat genau diese Länge: \texttt{char symvalue[MAXTOKENLEN]}. Direkt in der read Funktion wird bei zu großen Tokens ein Fehler ausgegeben, falls der Check if \texttt{tokenlen > MAXTOKENLEN} fehlschlägt. Hier ist bereits der Fehler zu erkennen da dass Array einen C-String der länge tokenlen nicht speichern kann, da von dem restlichen Programmteilen ein normaler C-String mit Null Terminierunt erwartet wird. 
Die neue Expression wird dann schließlich in der Funktion \texttt{creat\_exprsym(const char *s)} erstellt. Hier wird zuerst eine leere Expression erzeugt und dann mit Hilfe von 
\begin{lstlisting} 
strncat(new->symvalue, s, MAXTOKENLEN);
\end{lstlisting} mit dem String gefüllt. Ist nun der String s genau MAXTOKENLEN lang fügt strncat nach dieser Länge ein NULL Byte an dass sich dann nicht mehr innerhalb des Arrays befindet. \\
Wie bereits beschrieben befindet sich nach der symvalue direkt der Typ der Expression: \texttt{enum exprtype type}. Dieser wird jetzt mit dem NULL Byte von strncat überschrieben und so wird aus einer Expression des Types: EXPRSYM eine Expression mit dem Typen:EXPRPROC.\\
Wir diese Expression nun interpretiert liefert sie anstatt dem Variablenwert des symbols eine Prozedur die anschließend ausgeführt wird. Da unions verwendet wurden werden nun die ersten 4 bytes des strings als Adresse zu einer Prozedur interpretiert.
Beispielsweise liefert folgende eingabe
\begin{lstlisting}
> (define test abcdeeeeeeffffffffffgggggggggghh)
> test
 PROC: 0x64636261 
\end{lstlisting}
Dies bedeutet dass unter dem Symbol test ab jetzt eine Prozedur vergleichbar mit "+" gespeichert ist. Genau wie anderen Prozeduren kann der Prozedur Parameter übergeben werden. Dies sind mehrere Expressions die mit Hilfe eines next Pointers verbunden sind. Der Prozedur werden nur aufgelöste Werte übergeben. In unserem Fall ist der einzige Basis Typ ein 64 bit langer \texttt{long long int}. \\
Dies bedeutet dass wir der Prozedur nur \texttt{long long int} übergeben können. Ein Zeiger auf den ersten Wert wird direkt der Prozedur übergeben und kann somit auch für C Funktionen genutzt werden die nicht nicht wissen was eine Expression ist. Nehmen wir an dass wir eine Prozedur mit der Adresse der Linux system libc Funktion definiert haben, dann können man mit \texttt{define systemproc 0x68732f6e69622f)} die Funktion system aufrufen mit einem Zeiger auf den \texttt{long long int} der als \texttt{char *} interpretiert "/bin/sh". Dadurch würde sich eine interaktive Shell öffnen.
\subsection{Bestandteile des Exploits}
Das Exploit besteht im Grunde aus 3 Teilen.
\begin{enumerate}
\item Die Bash Datei exploit.sh beinhaltet den Hauptteil des Exploits. Da es für das Exploit notwendig ist mit dem Interpreter dynamisch zu interagieren werden temporär noch einige Dateien durch dieses Bash-Skript erzeugt. 
Alternativ wäre das Paket \texttt{expect}\footnote{\url{http://expect.sourceforge.net/}} zu verwendet, was die Interaktion erleichtert jedoch auf dem Zielsystem nicht verfügbar war. 
Um die Ausgabe in die Eingabe mit einzubeziehen wird mit Hilfe einer Redirection die Ausgabe in eine Datei umgeleitet. Diese Datei wird dann während der Eingabe mit einbezogen. 
In Bash kann dies z.B. so realisiert werden 
\begin{lstlisting}(
	echo "a"; 
	sleep 1; 
	verarbeiteAusgabe; 
	echo verarbeiteteAusgabe
	) | ./interpreter > output.txt
\end{lstlisting}
\item Das kleine C-Programm hexto32binary nimmt 4 Parameter. Der erste Eingabe Parameter ist eine Adresse, danach das Offset was von der Adresse abgezogen werden soll. Als drittes wird wieder eine Adresse übergeben und anschließend wieder ein Offset.
Die Übergabe passiert einfach anhand eines Strings der als hex oder int eine Zahl repräsentiert. Das C-Programm berechnet die neuen Adressen mithilfe der Offsets und gibt anschließend einen genau 32 byte langen String aus. Die ersten 4 byte des Strings sind die ASCII Zeichen die die erste Adresse im little Endian format repräsentiert. Die Bytes 10-14 sind wiederum die neu berechnete 2 Adresse. Die restlichen Bytes werden aufgefüllt mit 'a's.
\item Das Bash-Skript s.sh beinhaltet die Shell commands die die erreichte Shell ausführen soll. Dort werden die Streams angepasst und dann eine interaktive Shell("/bin/sh") gestartet.
\end{enumerate}
\subsection{Vorgehen}
Das Exploit lässt sich in mehrer Schritte unterteilen, die im Folgenden näher beleuchtet werden sollen. Anfangs wird durch aussnutzen der Lücke beschriben in \ref{luecke} eine Prozedur \texttt{printfproc} definiert die über die GOT die libc printf Funktion aufruft. Nun können wir printf direkt aus lisp heraus aufrufen und einen maximal 8 bytes (\texttt{sizeof(long long int}) langen String übergeben. Zuerst rufen wir printf mit \texttt{"\%2\$p\\n"} und \texttt{"\%9\$p\\n"} dies liefert eine Adresse aus der libc und eine Adresse aus dem heap, die beide randomisiert sind. Da die Offsets innerhalb der libc konstant sind kann man sich durch den ersten Wert die Adresse von system berechnet werden. Da auch malloc deterministisch arbeitet kann aus der zweiten Adresse die Adresse einer bestimmten Expression im Heap berechnet werden



